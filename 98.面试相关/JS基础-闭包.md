**以下代码中，标记 ？的地方分别输出什么**

~~~js
fun(n,o){
    console.log(o);
    return {
        fun:function(m){
            return fun(m,n)
        }
    }
}

var a = fun(0);		//?
a.fun(1);			//?
a.fun(2);			//?
a.fun(3);			//?

var b = fun(0).fun(1).fun(2).fun(3);	//?

var c = fun(0).fun(1);		//?
c.fun(2);					//?
c.fun(3);					//?
~~~

**答案见如下解析，分为三部分，分别解析**



**解析1：**

~~~js
var a = fun(0);
此时，调用fun()函数，并且传入0，即fun(0)
由于并没有o变量传入，所以第二句打印语句返回 undefined
该函数返回一个 包含fun方法的一个对象
即 a = {
    fun:function(m){
        return fun(m,n);
    }
}

a.fun(1);
即调用a对象的fun方法，并且传入了一个参数 1，此时 m = 1;
n等于向上寻找，找到第一个调用函数的时候传入的 n = 0;
所以 a.fun(1)  会返回 fun(1,0);
所以返回 0；

a.fun(2);
同 a.fun(1);	等价于fun(2,0);
所以返回0

a.fun(3);
同上
三次调用的都是同一个对象的同一个方法，对于a对象来说，不管如何调用，它的作用域没有发生变化，
即在a对象内，n永远等于最开始初始化传入的值，所以每次都会打印 0

答案：
undefined
0
0
0
~~~



**解析2**

~~~js
var b = fun(0).fun(1).fun(2).fun(3);

链式调用，我们顺着方法一步步往下走
第一步调用 fun(0)
	打印undefined，并且返回包含fun方法的对象
第二部调用 fun(0).fun(1)
	即在第一步返回的对象上，调用fun(1)
	此时 m = 1; n 等于上一次调用传入的第一个参数，即 n = 0;
	所以，第二步最终调用为 fun(1,0);
	打印 0，并返回包含fun方法的对象
第三部调用 fun(0).fun(1).fun(2)
	在第二步的返回对象上，调用fun(2)
	此时 m等于传入的参数 2，n等于上一步传入的第一个参数，即取1
    所以，第三步的最终调用为 fun(2,1)
	打印 1，并返回包含fun方法的对象
第四步调用 fun(0).fun(1).fun(2).fun(3)
	在第三步返回对象的基础上，调用fun(3)
	此时，m等于传入的参数 3，n等于上一次调用的第一个参数，即2
    所以，第第四步的最终调用为 fun(3,2)
	打印2，返回包含fun方法的对象
    
所以就是
答案：
undefined
0
1
2
~~~



**解析3**

~~~js
var c = fun(0).fun(1);
c.fun(2);
c.fun(3);

第一步和第二步
	fun(0).fun(1);
	同上，第一次调用返回undefined
    在第一次调用的返回对象上调用fun，传入的值为 1，即最终调用为 fun(1,0)
	所以，第二个返回 0
第三步调用
	c对象是第二步调用返回的对象，所以在c对象的作用域内，n = 1;
	第三部调用的最终调用即为 fun(2,1)
	返回 1
第四步调用
	第四步调用同第三步调用，c的作用域并没有发生变化
    所以第四步的最终调用为 fun(3,1)
	返回 1

答案：
undefined
0
1
1
~~~





**知识点：**

- 闭包的作用域


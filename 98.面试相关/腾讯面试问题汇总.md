# 一.跨域

> **说明：**由于浏览器的同源策略规定，某域下的客户端，在没有明确授权的情况下，不能读写另一个域的资源。而在实际的开发中，前后端常常是互相分离的，并且前后端的项目部署也常常不在一个服务器或者在服务器的不同端口下面，前端要想获取后端的数据，就必须要发送请求，如果不做一些处理，就会受到浏览器同源策略的约束。后端可以收到前端的请求并返回数据，但是前端无法接收到数据

## **1.1 常见的几种跨域方式**

- JSONP
- WebSocket
- CORS
- Hash
- postMessage

## 1.2 JSONP

> JSONP的原理就是借助HTML中的<script>标签可以跨域引入资源
>
> 所以可以动态创建一个<script>标签，src 为目的接口 + get数据包 + 处理数据的函数名
>
> 后台接收到GET请求之后解析并返回`函数名（数据）`给前端，前端<script>标签动态执行处理函数

**示例：**

~~~HTML
//前端
<script>
    var script = document.createElement( 'script' );
    script.type = 'text/javascript';

    // 传参并指定回调执行函数为getData
    script.src = 'http://localhost:8080/users?username=xbc&callback=handleData';
    document.body.appendChild( script );
    // 回调执行函数
    function handleData( res ) {
      data = JSON.stringify( res )
      console.log( data );
    }
  </script>
~~~

~~~js
//后台
var querystring = require('querystring');
var http = require('http');
var server = http.createServer();

server.on('request', function(req, res) {
    var params = querystring.parse(req.url.split('?')[1]);
    var fn = params.callback;

    // jsonp返回设置
    res.writeHead(200, { 'Content-Type': 'text/javascript' });
    var data = {
        user: 'xbc',
        password: '123456'
    }
    res.write(fn + '(' + JSON.stringify(data) + ')');

    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');
~~~

**解析：**

- 前端通过动态创建script标签，通过 src指定调用接口路径，传递数据包和回调函数

- 后台将数据惊醒处理，以前端调用的方式将回调函数返回并指定参数
- 前端执行回调函数并获取入参

**优点：**兼容性好

<font color='red'>**注意：**JSONP只支持HTTP的GET请求，不能解决两个页面之间如何进行JavaScript调用的问题</font>



## 1.2 CORS

[阮一峰--跨域资源共享 CORS详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)

> CORS是一个W3C标准，全称是跨域资源共享（Cross-origin resource sharing）
>
> 它允许浏览器向跨源服务器发送 XMLHttpRequest请求，从而克服 AJAX只能同源使用的限制
>
> 整个CORS通信过程，都是浏览器自动完成，不需要用户参与，对于开发者来说，CORS通信和传统的AJAX通信没有区别，代码完全一样
>
> 因此，实现CORS的关键就是服务器，只要服务器实现了CORS接口，就可以跨域通信

**浏览器讲CORS请求分成两大类，简单请求和非简单请求**

只要同时满足以下条件，就是简单请求

~~~js
1. 请求方法是以下几个字段
    - HEAD
    - GET
    - POST
2. HTTP的头部信息不超出以下几种字段
	- Accept
	- Accept-language
	- Content-language
	- Last-Event-ID
	- Content-Type
~~~

### 1.2.1 简单请求

- 对于简单请求，浏览器直接发出 CORS请求，具体来说，就是在头部信息中，增加一个 Origin字段

  - 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的的Http回应，浏览器发现，回应的信息中没有 Access-Control-Allow-Origin 字段，就知道报错了，从而抛出一个错误，被 XMLHttpRequest的onerror函数捕获
  - 入股Origin指定的源，在许可范围内，服务器的返回，会多出几个头信息字段

  ~~~js
  Access-Control-Allow-Origin: http://api.bob.com
  Access-Control-Allow-Credentials: true
  Access-Control-Expose-Headers: FooBar
  Content-Type: text/html; charset=utf-8
  ~~~

### 1.2.2 非简单请求

- 对于非简单请求，在发送正式通信之前，会增加一次Http查询请求，称为预检请求

  - 浏览器会先询问服务器，当前网页所在的域名是否在服务器的许可名单中，以及可以使用哪些HTTP动词和头信息字段，只有得到肯定的答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则报错
  - 预检请求使用的方法是 OPTIONS，表示这个请求是用来询问的

  ~~~js
  OPTIONS /cors HTTP/1.1
  Origin: http://api.bob.com
  Access-Control-Request-Method: PUT
  Access-Control-Request-Headers: X-Custom-Header
  Host: api.alice.com
  Accept-Language: en-US
  Connection: keep-alive
  User-Agent: Mozilla/5.0...
  ~~~



## 1.3 postMessage

- H5提出来的一个API
- **发送信息：**postMessage方法是向外界窗口发送消息

~~~js
someWindow.postMessage(message,targetOrigin)
~~~

- **接收消息：**message时间

~~~js
var onmessage = function(event) {
  var data = event.data;
  var origin = event.origin;
}

if(typeof window.addEventListener != 'undefined'){
    window.addEventListener('message',onmessage,false);
}else if(typeof window.attachEvent != 'undefined'){
    window.attachEvent('onmessage', onmessage);
}
~~~



## 1.4 WebSocket协议跨域

~~~js
<div>user input：<input type="text"></div>
<script src="./socket.io.js"></script>
<script>
var socket = io('http://www.domain2.com:8080');

// 连接成功处理
socket.on('connect', function() {
    // 监听服务端消息
    socket.on('message', function(msg) {
        console.log('data from server: ---> ' + msg); 
    });

    // 监听服务端关闭
    socket.on('disconnect', function() { 
        console.log('Server socket has closed.'); 
    });
});

document.getElementsByTagName('input')[0].onblur = function() {
    socket.send(this.value);
};
</script>
~~~



# 二.前端性能优化

# 三.浏览器缓存

# 四.http，报文的属性，常见的错误码，cookie

# 五.nodejs在项目中的作用

# 六.ES6新特性，数组的新增方法

# 七.socket
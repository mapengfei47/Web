# 一.作用域和闭包

[TOC]



## 1.作用域是什么

### 1.1 编译原理

程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”

- **词法分析：**这个过程将字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元。
  - 例如，var a = 2;被分解为 var，a，=，2，；。
- **语法分析：**将词法单元流（数组）转换为一个由元素逐级嵌套所组成的代表程序语法的结构树，这个树被称为抽象语法树
- **代码生成：**将抽象语法树转换为可执行代码的过程被称为代码生成

简单来说，任何JavaScript代码片段在执行前都要进行编译。

### 1.2 理解作用域

#### 1.2.1 运行时基本介绍

变量的赋值会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后运行时引擎会在作用域中查找该变量，如果能够找到就会对它进行赋值，否则报错

- **引擎：**从头到尾，负责整个JavaScript程序的编译和执行过程
- **编译器：**负责语法分析以及代码生成
- **作用域：**负责收集并维护所有声明的标识符，确定当前执行代码对这些标识符的访问权限



#### 1.2.2 LSH和RSH

当变量出现在赋值操作左侧时，进行LSH查询，当变量出现在赋值操作符右侧时，进行RSH查询

- LSH：查询赋值操作的目标是谁

- RSH：查询赋值操作的源头，即是谁要被赋值

  

#### 1.2.3模拟引擎和作用域的对话

~~~js
function foo(a){
    console.log(a);
}

foo(2);
~~~

> **让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。**
> **引擎：**我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗？
> **作用域：**别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。
> **引擎：**哥们太够意思了！好吧，我来执行一下 foo。
> **引擎：**作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗？
> **作用域：**这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。
> **引擎：**大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。
> **引擎：**哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗？
> **作用域：**咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。
> 给你。
> **引擎：**么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。
> **引擎：**哥们，能帮我再找一下对 a 的 RHS 引用吗？虽然我记得它，但想再确认一次。
> **作用域：**放心吧，这个变量没有变动过，拿走，不谢。
> **引擎：**真棒。我来把 a 的值，也就是 2，传递进 log(..)。



#### 1.2.4 作用域嵌套

作用域是存在嵌套性质，每次查找变量都会从最内层的作用域向上层作用域寻找，直到找到全局



#### 1.2.5练习

- 练习，列出以下过程中的LHS查询和RHS查询

~~~js
function foo(a){
    var b = a;
    return a + b;
}

var c = foo(2);
~~~

- **解答**
  - LSH
    - var c
    - foo(a)
    - var b
  - RSH
    - foo()
    - a
    - a
    - b


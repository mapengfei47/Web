# call和apply的实现

> call和apply函数都是用来绑定函数的this
>
> 唯一区别就是，call可以接收多个参数，而apply接收的事参数数组
>
> - `func.call(context,param1,param2)`
> - `func.apply(context,[param1,param2])`
>
> **注意：**
>
> - 当context为空的时候，指定的绑定的this视为 window对象



## call的实现

~~~js
var value = 888;

var myObj = {
    value: 'myCall调用成功'
}

var myFunc = function(name,age){
    return {
        value: this.value,
        name:name,
        age:age
    }
}

//自定义 myCall
Function.prototype.myCall = function(context){
    //如果 context不存在，则将其设置为window
    context = context || window;
    // 将调用的函数传给 context.fn
    context.fn = this;
    //获取参数数组
    var args = []
    for(var i=1;i<arguments.length;i++){
        args.push(arguments[i])
    }
    //调用方法,通过结构赋值传入参数
    var result = context.fn(...args)
    // 删除方法，返回结果
    delete contex.fn
    return result
}

//测试
myFunc.myCall(myObj,'Kobe',24)
~~~



## apply的实现

> apply的实现和call类似，唯一不同的是apply只能接收两个参数，且第二个参数是函数的参数数组

~~~js
var value = 888;

var myObj = {
    value: 'myApply调用成功'
}

var myFunc = function(name,age){
    return {
        value: this.value,
        name:name,
        age:age
    }
}

Function.prototype.myApply = function(context,arr){
    context = context || window;
    context.fn = this;
    var result;
    if(!arr){
        result = context.fn()
    }else{
        result = context.fn(...arr)
    }
    delete context.fn
    return result
}
~~~


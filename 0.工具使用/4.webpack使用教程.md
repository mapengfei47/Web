# Webpack使用教程

[TOC]

在开始之前，我们先来看以下Webpack官网首页的图片，思考已下该图片表达的意义​

![1563280838991](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1563280838991.png)



## 一.Webpack基本介绍

### 1.1 概念的引入

**思考：在网页中，我们经常会引入哪些常见的静态资源**

> - JS
>   - .js  .jsx  .coffee  .ts（TypeScript  类 C# 语言）
>
> - CSS
>   - .css  .less   .sass  .scss
>
> - Images
>   - .jpg   .png   .gif   .bmp   .svg
>
> - 字体文件（Fonts）
>   - .svg   .ttf   .eot   .woff   .woff2
>
> - 模板文件
>   - .ejs   .jade  .vue【这是在webpack中定义组件的方式，推荐这么用】

**问题：网页中静态资源多了以后存在的问题**

> 1. 网页加载速度变慢，因为要多次重复的发送资源请求
> 2. 要处理错综复杂的依赖关系

**如何解决上述两个问题？**

> 1. 合并、压缩、精灵图、图片的Base64编码
> 2. 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系；



### 1.2 什么是Webpack

**Webpack是一个前端的<font color='red'>项目构建工具</font>，它是基于node.js开发出来的一个前端工具**

**如何实现上述的2种解决方案？**

> 1. 使用Gulp， 是基于 task 任务的；
> 2. 使用Webpack， 是基于整个项目进行构建的；
>
> - 借助于webpack这个前端自动化构建工具，可以完美**实现资源的合并、打包、压缩、混淆**等诸多功能。
> - 根据官网的图片介绍webpack打包的过程
> - [webpack官网](https://www.webpackjs.com/)



### 1.3 安装Webpack

1. 运行 `npm i webpack -g` 全局安装Webpack，这样就能在全局使用Webpack命令
2. 在项目根目录运行 `npm i webpack --save-dev`安装到项目依赖中



## 二.Webpack基本使用

### 2.1 Webpack基本的使用方式-实例

**<font color='red'>目标：使用Webpack打包构建列表隔行变色案例</font>**

1. **创建基本的目录结构**

   webpack-study

   - dist
   - src
     - js
     - css
     - images
     - index.html
     - main.js

2. **在项目目录下面运行`npm init`初始化项目**

3. **使用 `npm i jquery --save` 安装jquery类库**

4. **创建main.js并书写各行变色的代码逻辑**

   ~~~js
   main.js
   
   //导入jquery内库
   import $ from 'jquery'
   
   $(function(){
       $("li:odd").css('backgroundColor','red')
       $("li:even").css('backgroundColor','tomato')
   })
   ~~~

5. 在页面直接引用main.js会报错，因为浏览器不认识ES6的新语法import，需要**使用Webpack进行处理**，Webpack默认会把这种高级语法转换为低级浏览器能够识别的语法

6. **运行 `webpack 入口文件路径 输出文件路径` 对main.js进行处理**

   ~~~powershell
   webpack ./src/main.js ./dist/bundle.js
   ~~~

7. **在index.html中引入bundle.js代替main.js**



### 2.2 Webpack基本配置

**<font color='red'>问题描述：</font>**

- **每次**修改文件之后，**都要**使用 `webpack 入口文件路径 输出文件路径`来对文件进行处理，使用起来比较**繁琐**

**<font color='red'>期待实现：</font>**

- **直接在控制台输入 webpack 命令**，即可自动完成文件的处理

**<font color='red'>实现方法</font>**

- 在项目根目录**添加Webpack的配置文件 webpack.config.js** 
  - 在Webpack配置文件里面**配置处理的入口文件和输出文件**
  - 配置完成之后，即可在调试台通过 webpack命令来对文件进行处理

~~~js
const path = require('path')


module.exports = {
    entry:path.join(__dirname,'./src/main.js'),

    output:{
        path:path.join(__dirname,'./dist'),
        filename:'bundle.js'
    }
}
~~~



## 三.webpack-dev-server的使用

### 3.1 实现自动打包编译

**<font color='red'>问题描述：每次改完代码，都需要手动执行`webpack`命令打包编译文件，比较繁琐</font>**

**目标：每次改完代码，我们点击保存之后就可以帮我们自动打包编译**

1. 安装 `webpack-dev-server`

   - -D 将该插件的依赖写入开发依赖中

   ~~~js
   npm install webpack-dev-server -D
   ~~~

2. 在 `package.json`里面的 `scripts`属性里面添加 `webpack-dev-server`命令到开发环境

   ~~~json
   "scripts": {
       "test": "echo \"Error: no test specified\" && exit 1",
       "dev": "webpack-dev-server"
     },
   ~~~

3. 在本地安装webpack，webpack-dev-server想要在本地项目中运行，必须在项目中也安装 webpack

   ~~~js
   npm install webpack -D
   ~~~

4. 执行 `npm run dev`命令即可,会有如下返回

   ![1563355443210](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1563355443210.png)

5. 由第四步可知，webpack-dev-server帮我们生成的bundle.js运行于项目根目录，这个文件并没有存到物理磁盘上，而是托管到了电脑内存中，所以我们在项目中根本看不到这个bundle.js文件，但是我们可以通过将index.html中的bundle.js引用路径修改为项目根路径，即可引用到该文件

   ~~~Js
   <script src="/bundle.js"></script>
   ~~~

6. 可以认为 `webpack-dev-server` 把打包好的文件，以一种虚拟的形式，托管到了项目的根目录中，虽然我们看不到它，但是可以认为和 `dist，src，nodemodule`，平级，有一个看不见的文件，叫做`bundle.js`

**<font color='red'>注意：</font>**

- 若安装过程中有中断，需要把 node-modules文件夹删掉，重新执行 npm install下载依赖，否则会报错
- 最后执行npm run dev 之后，就会开始自动监听我们的修改，每次修改保存都会触发自动打包编译



### 3.2 额外的参数

`webpack-dev-server` 除了帮我们实现自动编译打包的功能之外，还可以添加 **额外的参数帮我们实现更强大的功能**

#### 方式1（推荐）：

- 项目启动后自动打开浏览器：`--open`
- 指定项目端口号：`--port 3000`
- 指定项目启动后的主页面：`--contentBase src`
- 指定热加载：`--hot`
  - 不加热加载之前，每次修改都会生成一个新的bundle.js
  - 加了热加载之后，每次都会在原基础上更新bundle.js，提升 效率

~~~json
//package.json

"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "webpack-dev-server --open --port 3000 --contentBase src --hot"
  },
~~~

#### 方式2（了解即可）：

~~~js
//webpack.config.js

const webpack = require('webpack')	//引入Webpack，启用热更新的第2步

devServer:{     //设置dev-server命令参数的第二种形式，相对麻烦一些
        open:true,
        port:3000,
        contentBase:'src',
        hot:true    // 启用热更新的第一步
    },
    plugins:[       //配置插件的节点，热更新的第2步
        new webpack.HotModuleReplacementPlugin()    //new 一个热更新的模块对象，这是启用热更新的第3步
    ]
~~~



### 3.3 html-webpack-plugin插件

**<font color='red'>插件作用：</font>**

- **在内存中，生成HTML页面的插件**
- **将打包好的bundle.js插入页面中去，无需我们手动引入bundle.js**

**<font color='red'>插件用法：</font>**

1. **安装 html-webpack-plugin插件**

   ~~~js
   npm i html-webpack-plugin -D
   ~~~

2. **在webpack.config.js文件中添加插件**

   - 配置模版页面，即根据该模版页面生成内存中的页面
   - 指定生成页面的名称

   ~~~js
   //webpack.config.js
   
   const htmlWebpackPlugin = require('html-webpack-plugin')
   
   plugins:[ 
           new htmlWebpackPlugin({     //创建一个在内存中生成html页面的插件
               template:path.join(__dirname,'./src/index.html'),//指定模版页面，将来会根据指定的页面路径，去生成内存中的页面
               filename:'index.html'
           })
       ]
   ~~~

**<font color='red'>实际展示:</font>**

![1563374620348](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1563374620348.png)



### 拓展：-S，-D，-g说明

> **npm install module_name -S**    即    npm install module_name –save    <font color='red'>写入dependencies</font>
>
> **npm install module_name -D**    即    npm install module_name –save-dev <font color='red'>写入devDependencies</font>
>
> **npm install module_name -g** 	全局安装(命令行使用)
>
> **npm install module_name** 		本地安装(将安装包放在 ./node_modules 下)

**<font color='red'>dependencies与devDependencies有什么区别呢？</font>**

- devDependencies 里面的插件只用于开发环境，不用于生产环境

- dependencies 是需要发布到生产环境的



## 四.loader的使用

**<font color='red'>注意：Webpack默认只能打包处理Js类型的文件，无法处理其它的非Js类型的文件</font>**

**<font color='red'>如果要处理非Js类型的文件，我们需要手动安装一些合适的第三方loader加载器</font>**

### 4.1 loader处理样式表

1. **打包处理CSS文件：安装 style-loader css-loader**

   ```shell
   npm i style-loader css-loader -D
   ```

2. **在`webpack.config.js`配置文件里面新增`module`节点对象，在这个`module`对象身上，有个`rules`属性数组，这个数组中，存放了所有的第三方文件爱你的匹配和处理规则**

   ```js
   module:{        //这个节点，用来配置所有第三方模块加载器
           rules:[     //配置第三方模块的匹配规则
               {test:/\.css$/,use:['style-loader','css-loader']}   //配置处理 .css文件的第三方loader规则
           ]
       }
   ```

3. **在main.js入口文件里面引入CSS文件即可成功使用**

   ```Js
   import './css/index.css'
   ```



### 拓展：Webpack处理第三方文件类型的过程

> 1. 先校验文件类型，如果是js文件直接打包
> 2. 如果非js文件，拿到后缀名，去webpack.config.js里面找对应匹配规则
> 3. 找到则调用规则打包，否则报错
> 4. rules的use规则数组从右到左调用，会将后面调用完毕的处理结果交给前面的规则继续处理
> 5. 调用完毕之后会将处理结果直接交给Webpack进行打包合并，最终输出到bundle.js中去

**示例：**

- 先使用`css-loader`插件进行处理，将处理结果交给`style-loader`继续处理

~~~js
 module: { 
    rules: [ 
      { test: /\.css$/, use: ['style-loader', 'css-loader'] }
    ]
  }
~~~






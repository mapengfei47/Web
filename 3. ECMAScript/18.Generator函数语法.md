# Generator函数的语法

## 一.简介

### 1. 基本介绍

- **Generator是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同**
- **形式上，Generator函数是一个普通函数，但是有两个特征**
  - `function`关键字和函数名之间有一个`*`
  - 函数内部使用`yield`表达式，定义不同的内部状态
- **Generator函数的调用和普通方法一样，但是该函数并不执行，而是返回一个遍历器对象（Iterator Object）**

~~~js
function* GeneratorTest(){
    yeild:'hello';
    yeild:'world';
    return:'ending';
}

var gt = GeneratorTest();
~~~

- **通过调用遍历器对象的next（）方法，使得指针移向下一个状态**
  - 每次调用next（）方法，内部指针就从函数头部或者上一次停下来的地方开始执行，直到遇到下一个`yield`或者`return`语句

~~~js
gt.next();
//{value:'hello',done:false}

gt.next();
//{value:'world',done:false}

gt.next();
//{value:'ending',done:true}

gt.next();
//{value:undefined,done:true}
~~~

- **小结**
  - 调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针
  - 每次调用遍历器对象的next（）方法，都会返回一个有着value和done两个属性的对象
  - value代表当前内部状态的值，是yield表达式后面那个表达式的值
  - done属性是一个布尔值，表示当前遍历是否已经结束

### 2. yield表达式

- **在Generator函数中，yield表达式就是暂停标志**
- **遍历器对象的next（）方法运行逻辑如下**
  - 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的表达式，作为value进行返回，
  - 下一次调用next（），再继续往下执行，直到遇到下一个yield
  - 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式作为value返回
  - 如果没有return语句，则返回undefined作为value值返回



## 二.next()方法的参数

- **yield表达式本身没有返回值，或者说总返回undefined**
- **next方法可以带一个参数，该参数会被当做上一个yield表达式的返回值**

~~~js
function* f(x){
    var y = 2 * (yield (x + 1));
    var z = yield (y/3);
    return (x + y + z);
}

//案例1
var a = f(5);
a.next();		//{value:6,done:false}
a.next();		//{value:NaN,done:false}
a.next();		//{value:NaN,done:true}

//案例2
var b = f(5);
b.next();		//{value:6,done:false}
b.next(12);		//{value:8,done:false}
b.next(13);		//{value:42,done:true}
~~~

- **案例解析1**
  - 第二次调用next的时候，由于没有传入参数，所以 y = 2 * undefine即（NaN），除以3还是NaN，所以，第二次调用返回NaN
  - 第三次调用也没有传参，所以 z = undefined，所以最后return返回 5 + NaN + undefined即NaN

- **案例解析2**
  - 第二次调用的时候，传入了12，12会当做上一个yield的返回值，即 y = 2 * 12，即24，24/3即返回8
  - 第三次调用的时候，传入了13，所以z = 13，故想x + y + z = 5 + 24 + 13 = 42

- **注意：**
  - 由于next的传参是表示上一个yield的表达式的返回值，所以第一次调用next方法的时候，传参是无效的



## 三.for...of遍历

- **for...of可以遍历Generator函数运行时生成的iterator对象，并且此时不需要调用next方法**

~~~js
function* f(){
    yield 1;
    yield 2;
    yield 3;
    yield 4;
    yield 5;
    return 6;
}

for(let v of f()){
    console.log(v)
}
// 1
// 2
// 3
// 4
// 5
~~~

- **一旦next方法返回的对象的done为true，for...of循环就会终止，且不包含该返回对象**

- **除了for...of循环以外，扩展运算符，解构赋值和Array.from方法内部调用的，都是遍历接口，都可以将Generator函数返回的iterator对象作为参数**

~~~js
function* nums(){
    yield 1;
    yield 2;
    return 3;
    yield 4;
}

[...nums()]				//[1,2]
Array.from(num())		//[1,2]
let [x,y] = nums();
~~~


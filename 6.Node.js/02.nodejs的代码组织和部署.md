# nodejs的代码组织和部署

> 本章主要是对第一章知识的拓展，提供给基础好一点，或者想深入学习的同学
>
> 如果其中某些概念和用法暂时无法理解也没关系，我们继续往下面学习，等有一定的nodejs使用经验之后，再回过头来看这个，也会有所收获，同时，提升自己的理解

[TOC]

## 一. 模块路径解析规则

1. **绝对路径：**require支持以（/）或者盘符（C:）开头的绝对路径

2. **相对路径：**支持以（./开头的相对路径）

   ==**注意：**==但这两种路径在模块之间建立了强耦合关系，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发动全身，不建议使用。

3. **第三种形式的路径（常用方法）：**写法类似于`foo/bar`，按照以下规则进行解析，直到找到模块

   - **内置模块：**如果传递给require函数的是`NodeJS内`置模块名称，不做路径解析，直接返回内部模块的导出对象，例如`require('fs')`。

   - **node_modules目录：**`NodeJS`定义了一个特殊的node_modules目录用于存放模块。例如某个模块的绝对路径是`/home/user/hello.js`，在该模块中使用`require('foo/bar')`方式加载模块时，则`NodeJS`依次尝试使用以下路径

     - `/home/user/node_modules/foo/bar`
     - `/home/node_modules/foo/bar`
     - `/node_modules/foo/bar`

   - **NODE_PATH环境变量：**与PATH环境变量类似，`NodeJS`允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用`:`分隔，在Windows下使用`;`分隔。例如定义了以下NODE_PATH环境变量：

     - `NODE_PATH=/home/user/lib:/home/lib`

     当使用`require('foo/bar')`的方式加载模块时，则NodeJS依次尝试以下路径。

     - `/home/user/lib/foo/bar`
     - `/home/lib/foo/bar`

## 二. 包概念

`JS`模块的基本单位是单个的`JS`文件，但复杂些的模块往往由多个子模块组成。为了便于管理和使用，我们可以把由多个子模块组成的大模块称做`包`，并把所有子模块放在同一个目录里。

在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。例如有以下目录结构。

![1558592191798](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1558592191798.png)

其中cat定义了一个包，包含三个子模块，其中main作为模块入口文件

~~~js
// main.js

var head = require('./head');
var body = require('./body');

exports.create = function (name) {
    return {
        name: name,
        head: head.create(),
        body: body.create()
    };
};
~~~

一般情况下，使用路径：require('/home/lib/cat/main')可以获取入口文件，但是为了使包看起来更像是一个单独的模块，可以有如下方法：

**index.js：**当入口文件名为index.js的时候，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。

- require("/home/lib/cat")
- require("/home/lib/cat/index")

这样处理后，就只需要把包目录路径传递给`require`函数，感觉上整个目录被当作单个模块使用，更有整体感。

**package.json：**如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个`package.json`文件，并在其中指定入口模块的路径。上例中的`cat`模块可以重构如下。

![1558592898535](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1558592898535.png)

其中package.json文件的内容如下

~~~json
{
    "name": "cat",
    "main": "./lib/main.js"
}
~~~

如此一来，就同样可以使用`require('/home/lib/cat')`的方式加载模块。NodeJS会根据包目录下的`package.json`找到入口模块所在位置。

## 三. 工程目录

~~~js
- /home/user/workspace/node-echo/   # 工程目录
    - bin/                          # 存放命令行相关代码
        node-echo
    + doc/                          # 存放文档
    - lib/                          # 存放API相关代码
        echo.js
    - node_modules/                 # 存放三方包
        + argv/
    + tests/                        # 存放测试用例
    package.json                    # 元数据文件
    README.md                       # 说明文件
~~~

 其中部分文件内容如下所示

~~~js
/* bin/node-echo */
var argv = require('argv'),
    echo = require('../lib/echo');
console.log(echo(argv.join(' ')));

/* lib/echo.js */
module.exports = function (message) {
    return message;
};

/* package.json */
{
    "name": "node-echo",
    "main": "./lib/echo.js"
}
~~~

以上例子中分类存放了不同类型的文件，并通过`node_moudles`目录直接使用三方包名加载模块。此外，定义了`package.json`之后，`node-echo`目录也可被当作一个包来使用。

## 四. NPM

`NPM`是随同`nodejs`一同安装的包管理工具，能解决`NodeJS`代码部署上的很多问题，常见的使用场景有以下几种：

- 允许用户从`NPM`服务器下载别人编写的三方包到本地使用。
- 允许用户从`NPM`服务器下载并安装别人编写的命令行程序到本地使用。
- 允许用户将自己编写的包或命令行程序上传到`NPM`服务器供别人使用。

### 4.1 下载第三方包

在npm官网搜索要下载的包，知道包名后，在命令行输入如下命令进行下载即可

~~~js
npm install 包名
npm install 包名@指定version
~~~

 默认下载最新版本的包，要下载指定版本的包，在包名后面添加`@指定version`即可

如果需要下载的第三方包比较多，可以通过在package.json配置中指定依赖以及版本，然后在工程目录下面运行`npm install`命令即可进行**批量下载安装**

更重要的是，以后该项目上传到了npm服务器上面之后，别人下载了该项目，会自动添加该项目的依赖文件

~~~json
{
    "name": "node-echo",
    "main": "./lib/echo.js",
    "dependencies": {
        "argv": "0.0.2"
    }
}
~~~

### 4.2 安装命令行程序

从`NPM`服务上下载安装一个命令行程序的方法与三方包类似。

- `npm install 安装包名 -g`

### **4.3 发布代码**

第一次使用`NPM`发布代码前需要注册一个账号。终端下运行`npm adduser`，之后按照提示做即可。账号搞定后，接着我们需要编辑`package.json`文件，加入`NPM`必需的字段。

~~~json
{
    "name": "node-echo",           # 包名，在NPM服务器上须要保持唯一
    "version": "1.0.0",            # 当前版本号
    "dependencies": {              # 三方包依赖，需要指定包名和版本号
        "argv": "0.0.2"
      },
    "main": "./lib/echo.js",       # 入口模块位置
    "bin" : {
        "node-echo": "./bin/node-echo"      # 命令行程序名和主模块位置
    }
}
~~~

之后，我们就可以在`package.json`所在目录下运行`npm publish`发布代码了。

### **4.4 版本号**

使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。

语义版本号分为`X.Y.Z`三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。

~~~tex
+ 如果只是修复bug，需要更新Z位。

+ 如果是新增了功能，但是向下兼容，需要更新Y位。

+ 如果有大变动，向下不兼容，需要更新X位。
~~~

版本号有了这个保证后，在申明三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如`"argv": "0.0.x"`表示依赖于`0.0.x`系列的最新版`argv`。`NPM`支持的所有版本号范围指定方式可以查看[官方文档](https://npmjs.org/doc/files/package.json.html#dependencies)。

### 4.5 npm使用拓展

除了本章介绍的部分外，NPM还提供了很多功能，`package.json`里也有很多其它有用的字段。除了可以在[npmjs.org/doc/](https://npmjs.org/doc/)查看官方文档外，这里再介绍一些NPM常用命令。

- NPM提供了很多命令，例如`install`和`publish`，使用`npm help`可查看所有命令。
- 使用`npm help <command>`可查看某条命令的详细帮助，例如`npm help install`。
- 在`package.json`所在目录下使用`npm install . -g`可先在本地安装当前命令行程序，可用于发布前的本地测试。
- 使用`npm update <package>`可以把当前目录下`node_modules`子目录里边的对应模块更新至最新版本。
- 使用`npm update <package> -g`可以把全局安装的对应命令行程序更新至最新版。
- 使用`npm cache clear`可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。
- 使用`npm unpublish <package>@<version>`可以撤销发布自己发布过的某个版本代码。

## 五. 小结

本章介绍了使用NodeJS编写代码前需要做的准备工作，总结起来有以下几点：

- 编写代码前先规划好目录结构，才能做到有条不紊。
- 稍大些的程序可以将代码拆分为多个模块管理，更大些的程序可以使用包来组织模块。
- 合理使用`node_modules`和`NODE_PATH`来解耦包的使用方式和物理路径。
- 使用NPM加入NodeJS生态圈互通有无。
- 想到了心仪的包名时请提前在NPM上抢注。
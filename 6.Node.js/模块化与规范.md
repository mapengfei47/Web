## 模块化与规范

### 1. 模块化的基本了解

**为解决：**命令冲突和引入的文件依赖繁琐的问题，产生了模块化的概念

**模块化编程的目的是：**封装细节，提供使用接口，使模块之间彼此互不影响，相互独立，实现某一特定的功能。如果其它模块想调用的时候，可以暴露我们希望对外公开的方法和数据。

**eg：**模块化编程的基础思想代码示例

- 使用闭包定义私有变量和函数，外部无法访问他们
- 通过 return向外公开我们希望对外公开的属性和方法
- 可以将依赖将参数的形式传进来在内部使用

~~~js
var myModule = (function (a) { 

       var value =a.value;
　　　　var f1 = function(){
　　　　　　//...
　　　　};

　　　　var f2 = function(){
　　　　　　//...
　　　　};

　　　　return {
          value: value,
　　　　　　f2 : f2
　　　　};
}(a));
~~~



### 2. CommonJS规范

**模块定义：**一个文件就是一个模块，用module变量代表当前模块。Node在其内部定义了一个Module的构造函数，所有的module都是 Module的实例

**CommonJS实例**

~~~js
function Module(id, parent) {
  //模块的标识符，通常是带有绝对路径的模块文件名
  this.id = id;
  //初始值为一个空对象，表示对外输出的一个接口
  this.exports = {};
  //返回一个对象，表示调用该模块的模块
  this.parent = parent;
  //模块的文件名，带有绝对路径
  this.filename = null;
  //表示一个模块是否加载完毕
  this.loaded = false;
  //表示该模块要用到的其它模块
  this.children = [];
}
module.exports = Module;
var module = new Module(filename, parent);
~~~

**模块的引用：**require（"文件路径"）

require函数的基本功能是，读取并执行一个js文件，返回该模块的module.exports



### 3. AMD规范

**模块定义：**AMD(Asynchronous Module Definition)，也就是异步模块定义。AMD规范，制定了定义模块的规则，使得模块之间的依赖可以被异步加载。这和浏览器的异步加载模块的环境刚好适应（浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题）。

**语法：**define(id,dependencies,factory)

- id：定义中，模块的名字
- dependencies：模块中所依赖的模块数组
- factory：模块初始化要执行的函数或对象

**require方法（加载模块）：**require（[module]，callback)

- 第一个参数为要加载的模块数组，
- 第二个参数为加载成功之后的回调函数

**AMD实例**

~~~js
define("a", ["require", "exports", "b"], function (require, exports, b) {
       exports.funb = function() {
           return b.funb();
           //Or:
           return require("b").funb();
       }
   });
~~~

### 4. RequireJS规范

RequireJs遵循AMD规范

**定义模块：define（id?,dependencies?,factory）**

**引入模块：require（dependencies?,factory）**

**配置模块：require.config({})**

**参数解析：**

- 带问号的为可选参数
- define函数比require函数多一个id参数

**define函数和require函数的区别：**这两个函数内部机制差不多，不一样的地方是define的回调函数需要有return语句返回模块对象，这样需要引用模块的时候，才能够被其它模块引用到，而require函数不需要return语句
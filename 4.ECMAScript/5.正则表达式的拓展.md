# 正则表达式的拓展

[TOC]

## 一. RegExp构造函数

1. **在ES5中，RegExp构造函数的参数有两种**

   - 字符串，修饰符

   - 正则表达式

     ~~~js
     new RegExp('xyz',i);
     new RegExp(/xyz/i);
     ~~~

2. **在使用参数为正则表达式的时候，ES5不允许使用第二个参数添加修饰符，否则会报错。ES6打破了这个规则**

   - 在使用正则表达式作为参数的时候，第二个参数可以指定修饰符，这时候新指定的修饰符，将会覆盖原来的修饰符

   - 在如下示例中，i会覆盖ig

     ~~~js
     new RegExp(/xyz/ig,i)
     ~~~

     

## 二.字符串的正则方法

1. 字符串对象共有5个方法，可以使用正则表达式，**ES6在内部，将与正则表达式相关的方法，全部定义在RegExp对象内部**
   - matchAll（）
   - match（）
   - replace（）
   - search（）
   - split（）



## 三.新增的修饰符

1. **u修饰符**
   - ES6为正则表达式添加了u修饰符，含义为 ‘Unicode’ 模式，**用来处理大于\uFFFF的unicode字符**，也就是说，会正确处理四个字节的 UTF-16编码

2. **y修饰符**
   - **y修饰符也叫作粘连修饰符**，作用与g修饰符类似，也是全局匹配，不同之处在于，g修饰符只要剩余的位置中存在匹配元素即可，而y修饰符要求，必须从剩余的第一个位置开始匹配

3. **s修饰符**

   - 在正则表达式中，**点 . 是一个特殊字符，可以代表任意单个字符**，但是有两个例外

     - 四个字节的 UTF-16字符，可以使用 u修饰符解决
     - 另一个是终止符，即表示一行的结束，以下四个字符表示终止符
       - 换行符（\n）
       - 回车符（\r）
       - 行分隔符
       - 段分隔符

   - **为了实现使用点 . 匹配任意字符的诉求****，ES6新增了s修饰符**

   - 使用 s修饰符的方法被称为 `doAll` 模式，可以使用doAll属性判断是否处于doAll模式

     ~~~js
     /foo.bar/.test('foo\nbar');			//false
     /foo.bar/s.test('foo\nbar');		//true
     ~~~

## 四.新增的属性

1. **判断是否设置了u修饰符：`RegExp.prototype.unicode`**

2. **判断是否设置了y修饰符：`RegExp.prototype.sticky`**

3. **返回正则表达式的修饰符：`RegExp.prototype.flags`**

   ~~~js
   var r = /hello\d/uy;
   r.unicode;		//true
   r.sticky;		//true
   r.flags;		//uy
   ~~~

4. **判断正则表达式是否处于doAll模式（即是否包含s修饰符）**

   ~~~js
   var r1 = /foo.bar/;
   var r2 = /foo.bar/s;
   r1.doAll;		//false
   r2.doAll;		//true
   ~~~



## //东西比较多，理解能力有限，待更新



## 总结

1. ES6扩展了正则表达式的构造函数，当构造函数的参数是正则表达式对象时，也可以定义第二个参数作为修饰符覆盖原始的修饰符
2. ES6将字符串涉及的正则表达式方法全部定义到了RegExp对象内部
3. ES6新增了如下修饰符和相应的属性查询方法
   - s 修饰符，可以用来匹配任意字符串，使用 doAll属性查询是否设置了s修饰符
   - y修饰符，类似于g修饰符，也叫作粘连修饰符，匹配的下一个元素从剩余元素的第一个开始算，使用sticky查询是否设置了y修饰符
   - u修饰符，用来处理大于\uFFFF的unicode字符，即正确处理四个字节的 UTF-16编码，可以使用unicode属性查询是否设置了u修饰符

4. ES6新增了flags属性，来查询正则表达式的修饰符